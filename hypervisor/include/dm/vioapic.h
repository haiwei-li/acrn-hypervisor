/*-
 * Copyright (c) 2013 Tycho Nightingale <tycho.nightingale@pluribusnetworks.com>
 * Copyright (c) 2013 Neel Natu <neel@freebsd.org>
 * Copyright (c) 2017-2024 Intel Corporation.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY NETAPP, INC ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL NETAPP, INC OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $FreeBSD$
 */

#ifndef VIOAPIC_H
#define VIOAPIC_H

#include <asm/apicreg.h>
#include <asm/ioapic.h>
#include <util.h>

/**
 * @defgroup vp-dm_vioapic vp-dm.vioapic
 * @ingroup vp-dm
 * @brief Implementation of the virtual I/O APIC in hypervisor.
 *
 * This module emulates the virtual I/O APIC in the hypervisor. The I/O APIC is responsible for receiving interrupts
 * generated by system hardware and I/O devices and forwarding them to the local APIC as interrupt messages.
 *
 * @{
 */

/**
 * @file
 * @brief All APIs to support virtual IOAPIC.
 *
 * This file defines macros, structures and function declarations for the virtual I/O APIC.
 */

#define	VIOAPIC_BASE	0xFEC00000UL
#define	VIOAPIC_SIZE	4096UL

#define REDIR_ENTRIES_HW	120U /* Service VM align with native ioapic */
#define STATE_BITMAP_SIZE	INT_DIV_ROUNDUP(REDIR_ENTRIES_HW, 64U)

#define IOAPIC_RTE_LOW_INTVEC	((uint32_t)IOAPIC_RTE_INTVEC)

/**
 * @brief Data structure to illustrate a I/O APIC for a VM.
 *
 * This data structure contains the information of one I/O APIC for a VM. The I/O APIC is responsible for receiving
 * interrupts generated by system hardware and I/O devices and forwarding them to local APICs as interrupt messages.
 *
 * @consistency self.vm->arch_vm.vioapics.vioapic_array[X] == self
 * @alignment N/A
 *
 * @remark N/A
 */
struct acrn_single_vioapic {
	spinlock_t lock; /**< The spinlock to protect simultaneous access of all elements. */
	struct acrn_vm *vm; /**< Pointer to the VM that owns this I/O APIC. */
	struct ioapic_info chipinfo; /**< The information of this I/O APIC. */
	/**
	 * @brief The register to read or write.
	 *
	 * Except for IOREGSEL (index) and IOWIN (data) registers, all other registers are indirect registers. To access
	 * I/O APIC indirect registers, the guest writes the register index to the index register and then reads/writes
	 * the register value from/to the data register. This field is used to store the register index.
	 */
	uint32_t ioregsel;
	union ioapic_rte rtbl[REDIR_ENTRIES_HW]; /**< The redirection table of this I/O APIC. */
	uint64_t pin_state[STATE_BITMAP_SIZE]; /**< The status bitmap of all pins: 1 - high, 0 - low. */
};

/**
 * @brief Data structure to illustrate all I/O APICs for a VM.
 *
 * This data structure contains the information of all I/O APICs for a VM.
 *
 * @consistency self.vioapic_array[X].vm->arch_vm.vioapics == self
 * @alignment N/A
 *
 * @remark N/A
 */
struct acrn_vioapics {
	uint8_t ioapic_num; /**< The number of I/O APICs emulated for the VM. */
	uint32_t nr_gsi; /**< The maximum number of GSI emulated for the VM. */
	struct acrn_single_vioapic vioapic_array[CONFIG_MAX_IOAPIC_NUM]; /**< The array of virtual I/O APICs. */
};

void dump_vioapic(struct acrn_vm *vm);
void vioapic_init(struct acrn_vm *vm);
void reset_vioapics(const struct acrn_vm *vm);

/**
 * @brief Set vIOAPIC IRQ line status.
 *
 * @param[in] vm        Pointer to target VM
 * @param[in] vgsi	GSI for the virtual interrupt
 * @param[in] operation Action options: GSI_SET_HIGH/GSI_SET_LOW/
 *			GSI_RAISING_PULSE/GSI_FALLING_PULSE
 *
 * @pre irqline < vioapic_pincount(vm)
 */
void	vioapic_set_irqline_lock(const struct acrn_vm *vm, uint32_t vgsi, uint32_t operation);

/**
 * @brief Set vIOAPIC IRQ line status.
 *
 * Similar with vioapic_set_irqline_lock(),but would not make sure
 * operation be done with ioapic lock.
 *
 * @param[in] vm        Pointer to target VM
 * @param[in] vgsi      GSI for the virtual interrupt
 * @param[in] operation Action options: GSI_SET_HIGH/GSI_SET_LOW/
 *			GSI_RAISING_PULSE/GSI_FALLING_PULSE
 *
 * @pre irqline < vioapic_pincount(vm)
 */
void	vioapic_set_irqline_nolock(const struct acrn_vm *vm, uint32_t vgsi, uint32_t operation);

uint32_t get_vm_gsicount(const struct acrn_vm *vm);
void	vioapic_broadcast_eoi(const struct acrn_vm *vm, uint32_t vector);
void	vioapic_get_rte(const struct acrn_vm *vm, uint32_t vgsi, union ioapic_rte *rte);
int32_t	vioapic_mmio_access_handler(struct io_request *io_req, void *handler_private_data);
struct acrn_single_vioapic *vgsi_to_vioapic_and_vpin(const struct acrn_vm *vm, uint32_t vgsi, uint32_t *vpin);

/**
 * @}
 */

/* End of acrn_vioapic */
#endif /* VIOAPIC_H */
